{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures. Included models: Ising model Attractive Hubbard model Included Monte Carlo flavors Classical Monte Carlo Determinant Quantum Monte Carlo (also known as auxiliary field Monte Carlo) Included lattices Cubic lattices (chain, square, cube, ...) Any ALPS lattice Have a look at the Showcase section to get some inspiration. Study your own model A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes. To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC) . Practically, it makes sense to start by taking a look at the implementation of one of the predefined models. If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request ! GitHub MonteCarlo.jl is open-source . The source code can be found on github . Criticism and contributions are very much welcome - just open an issue . For more details see the Contribution Guide .","title":"Introduction"},{"location":"#introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","title":"Introduction"},{"location":"#included-models","text":"Ising model Attractive Hubbard model","title":"Included models:"},{"location":"#included-monte-carlo-flavors","text":"Classical Monte Carlo Determinant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","title":"Included Monte Carlo flavors"},{"location":"#included-lattices","text":"Cubic lattices (chain, square, cube, ...) Any ALPS lattice Have a look at the Showcase section to get some inspiration.","title":"Included lattices"},{"location":"#study-your-own-model","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes. To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC) . Practically, it makes sense to start by taking a look at the implementation of one of the predefined models. If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request !","title":"Study your own model"},{"location":"#github","text":"MonteCarlo.jl is open-source . The source code can be found on github . Criticism and contributions are very much welcome - just open an issue . For more details see the Contribution Guide .","title":"GitHub"},{"location":"customize/","text":"Customize Custom models Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC) . Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model. General remarks for lattice models Semantics For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model). Note We will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations. Lattice requirements The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information. It might be educating to look at the structure of the simple SquareLattice struct. mutable struct SquareLattice : AbstractCubicLattice L :: Int sites :: Int neighs :: Matrix { Int } # row = up, right, down, left; col = siteidx neighs_cartesian :: Array { Int , 3 } # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx sql :: Matrix { Int } SquareLattice () = new () end It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian . If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example. Custom lattices As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements ). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view. Mandatory fields Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice . To work with a Monte Carlo flavor, it must internally have at least have the following field, sites : number of lattice sites. However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like neighs : next nearest neighbors, as most Hamiltonian will need next nearest neighbor information. The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model . Custom Monte Carlo flavors Coming soon...","title":"Customize"},{"location":"customize/#customize","text":"","title":"Customize"},{"location":"customize/#custom-models","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC) . Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","title":"Custom models"},{"location":"customize/#general-remarks-for-lattice-models","text":"","title":"General remarks for lattice models"},{"location":"customize/#semantics","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model). Note We will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","title":"Semantics"},{"location":"customize/#lattice-requirements","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information. It might be educating to look at the structure of the simple SquareLattice struct. mutable struct SquareLattice : AbstractCubicLattice L :: Int sites :: Int neighs :: Matrix { Int } # row = up, right, down, left; col = siteidx neighs_cartesian :: Array { Int , 3 } # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx sql :: Matrix { Int } SquareLattice () = new () end It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian . If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","title":"Lattice requirements"},{"location":"customize/#custom-lattices","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements ). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","title":"Custom lattices"},{"location":"customize/#mandatory-fields","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice . To work with a Monte Carlo flavor, it must internally have at least have the following field, sites : number of lattice sites. However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like neighs : next nearest neighbors, as most Hamiltonian will need next nearest neighbor information. The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model .","title":"Mandatory fields"},{"location":"customize/#custom-monte-carlo-flavors","text":"Coming soon...","title":"Custom Monte Carlo flavors"},{"location":"lattices/","text":"Lattices The package ships with a couple of standard lattices Type Description MonteCarlo.Chain 1-dimensional chain MonteCarlo.SquareLattice 2-dimensional square lattice MonteCarlo.CubicLattice D-dimensional cubic lattice It also provides routines to load the following common lattice formats Type Description MonteCarlo.ALPSLattice ALPS simple lattice graph (XML file) Didn't find your desired lattice? Just implement your own lattice for later use in a model of choice. See Custom lattices .","title":"Lattices"},{"location":"lattices/#lattices","text":"The package ships with a couple of standard lattices Type Description MonteCarlo.Chain 1-dimensional chain MonteCarlo.SquareLattice 2-dimensional square lattice MonteCarlo.CubicLattice D-dimensional cubic lattice It also provides routines to load the following common lattice formats Type Description MonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","title":"Lattices"},{"location":"lattices/#didnt-find-your-desired-lattice","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices .","title":"Didn't find your desired lattice?"},{"location":"flavors/dqmc/","text":"Determinant Quantum Monte Carlo (DQMC) This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model . You can initialize a determinant quantum Monte Carlo simulation of a given model simply through dqmc = DQMC ( model , beta = 5.0 ) Mandatory keywords are: beta : inverse temperature Allowed keywords are: delta_tau::Float64 = 0.1 : imaginary time step size safe_mult::Int = 10 : stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?) checkerboard::Float64 = false : use Checkerboard decomposition (faster) sweeps : number of measurement sweeps thermalization : number of thermalization (warmup) sweeps seed : initialize DQMC with custom seed all_checks::Bool = true : turn off to suppress some numerical checks Afterwards, you can run the simulation by run! ( dqmc ) Technical details Symmetric Suzuki-Trotter decomposition We use the symmetric version of the Suzuki-Trotter decomposition, i.e. \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = \\prod*j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = \\prod*j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} where T T is the hopping matrix and V(l) V(l) is the interaction matrix with l l an imaginary time slice index indicating an auxiliary field dependence. With the imaginary time slice matrices B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2} B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2} the equal-time Green's function is G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} . Checkerboard decomposition We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice . The only requirement is that the AbstractLattice has the following two fields, n_bonds::Int : total number of bonds (lattice graph edges) bonds::Matrix{Int} : bond matrix of shape (n_bonds, 3) . Rows correspond to bonds and columns indicate source site, target site, and bond type in this order. Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype. # MonteCarlo.build_checkerboard Method . build_checkerboard ( l :: Lattice ) - checkerboard , groups , n_groups Generic checkerboard construction. The methods returns * checkerboard::Matrix{Int} : size (3, n_bonds) where rows = source site , target site , bondid and cols correspond to bonds. Sorted (along columns) in such a way that checkerboard[3, groups[i]] are all the bond indices corresponding to the i-th group. * groups::Vector{UnitRange} : ranges indicating which columns of checkerboard belong to which checkerboard group. * n_groups::Int : number of checkerboard groups. source Effective slice matrices and Green's function Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a a and b b ) \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\\\ \\times \\left( \\prod*j e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\\\ &\\times \\left( \\prod*j e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} For performance resons we internally work with effective imaginary time slice matrices B_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} B_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} instead of the original B_l B_l s above. Warning Note that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + B*M \\cdots B*1 \\right)^{-1} \\\\ &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\left( 1 + B^{\\text{eff}}*M \\cdots B^{\\text{eff}}*1 \\right)^{-1} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a/2} \\\\ &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} G^{\\text{eff}} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a/2} \\end{align} To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC) . Note that although G\\overset{!}{=}G^\\text{eff} G\\overset{!}{=}G^\\text{eff} } one can readily show that \\det G = \\det G^{\\text{eff}} \\det G = \\det G^{\\text{eff}} holds and the Metropolis acceptance is not affected by switching to the effective matrices. Exports # MonteCarlo.greens Method . greens ( mc :: DQMC ) Obtain the current equal-time Green's function. Internally, mc.s.greens is an effective Green's function. This method transforms this effective one to the actual Green's function by multiplying hopping matrix exponentials from left and right. source # MonteCarlo.run! Method . run! ( mc :: DQMC [; verbose :: Bool = true , sweeps :: Int , thermalization :: Int ]) Runs the given Monte Carlo simulation mc . Progress will be printed to stdout if verbose=true (default). source # MonteCarlo.DQMC Type . Determinant quantum Monte Carlo (DQMC) simulation source # MonteCarlo.DQMC Method . DQMC ( m :: M ; kwargs ... ) where M : Model Create a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs . source # MonteCarlo.DQMC Method . DQMC ( m :: M , params :: Dict ) DQMC ( m :: M , params :: NamedTuple ) Create a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params . source Potential extensions Pull requests are very much welcome! todo","title":"DQMC"},{"location":"flavors/dqmc/#determinant-quantum-monte-carlo-dqmc","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model . You can initialize a determinant quantum Monte Carlo simulation of a given model simply through dqmc = DQMC ( model , beta = 5.0 ) Mandatory keywords are: beta : inverse temperature Allowed keywords are: delta_tau::Float64 = 0.1 : imaginary time step size safe_mult::Int = 10 : stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?) checkerboard::Float64 = false : use Checkerboard decomposition (faster) sweeps : number of measurement sweeps thermalization : number of thermalization (warmup) sweeps seed : initialize DQMC with custom seed all_checks::Bool = true : turn off to suppress some numerical checks Afterwards, you can run the simulation by run! ( dqmc )","title":"Determinant Quantum Monte Carlo (DQMC)"},{"location":"flavors/dqmc/#technical-details","text":"","title":"Technical details"},{"location":"flavors/dqmc/#symmetric-suzuki-trotter-decomposition","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e. \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = \\prod*j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = \\prod*j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} where T T is the hopping matrix and V(l) V(l) is the interaction matrix with l l an imaginary time slice index indicating an auxiliary field dependence. With the imaginary time slice matrices B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2} B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2} the equal-time Green's function is G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} .","title":"Symmetric Suzuki-Trotter decomposition"},{"location":"flavors/dqmc/#checkerboard-decomposition","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice . The only requirement is that the AbstractLattice has the following two fields, n_bonds::Int : total number of bonds (lattice graph edges) bonds::Matrix{Int} : bond matrix of shape (n_bonds, 3) . Rows correspond to bonds and columns indicate source site, target site, and bond type in this order. Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype. # MonteCarlo.build_checkerboard Method . build_checkerboard ( l :: Lattice ) - checkerboard , groups , n_groups Generic checkerboard construction. The methods returns * checkerboard::Matrix{Int} : size (3, n_bonds) where rows = source site , target site , bondid and cols correspond to bonds. Sorted (along columns) in such a way that checkerboard[3, groups[i]] are all the bond indices corresponding to the i-th group. * groups::Vector{UnitRange} : ranges indicating which columns of checkerboard belong to which checkerboard group. * n_groups::Int : number of checkerboard groups. source","title":"Checkerboard decomposition"},{"location":"flavors/dqmc/#effective-slice-matrices-and-greens-function","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a a and b b ) \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} = e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\\\ \\times \\left( \\prod*j e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} \\begin{align} e^{-\\Delta\\tau \\sum*l T+V(l)} &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\\\ &\\times \\left( \\prod*j e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align} For performance resons we internally work with effective imaginary time slice matrices B_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} B_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} instead of the original B_l B_l s above. Warning Note that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + B*M \\cdots B*1 \\right)^{-1} \\\\ &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} \\left( 1 + B^{\\text{eff}}*M \\cdots B^{\\text{eff}}*1 \\right)^{-1} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a/2} \\\\ &= e^{\\Delta\\tau T*a/2} e^{\\Delta\\tau T*b/2} G^{\\text{eff}} e^{-\\Delta\\tau T*b/2} e^{-\\Delta\\tau T*a/2} \\end{align} To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC) . Note that although G\\overset{!}{=}G^\\text{eff} G\\overset{!}{=}G^\\text{eff} } one can readily show that \\det G = \\det G^{\\text{eff}} \\det G = \\det G^{\\text{eff}} holds and the Metropolis acceptance is not affected by switching to the effective matrices.","title":"Effective slice matrices and Green's function"},{"location":"flavors/dqmc/#exports","text":"# MonteCarlo.greens Method . greens ( mc :: DQMC ) Obtain the current equal-time Green's function. Internally, mc.s.greens is an effective Green's function. This method transforms this effective one to the actual Green's function by multiplying hopping matrix exponentials from left and right. source # MonteCarlo.run! Method . run! ( mc :: DQMC [; verbose :: Bool = true , sweeps :: Int , thermalization :: Int ]) Runs the given Monte Carlo simulation mc . Progress will be printed to stdout if verbose=true (default). source # MonteCarlo.DQMC Type . Determinant quantum Monte Carlo (DQMC) simulation source # MonteCarlo.DQMC Method . DQMC ( m :: M ; kwargs ... ) where M : Model Create a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs . source # MonteCarlo.DQMC Method . DQMC ( m :: M , params :: Dict ) DQMC ( m :: M , params :: NamedTuple ) Create a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params . source","title":"Exports"},{"location":"flavors/dqmc/#potential-extensions","text":"Pull requests are very much welcome! todo","title":"Potential extensions"},{"location":"flavors/mc/","text":"Monte Carlo (MC) This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model ). You can initialize a Monte Carlo simulation of a given model simply through mc = MC ( model ) Allowed keywords are: beta : inverse temperature sweeps : number of measurement sweeps thermalization : number of thermalization (warmup) sweeps global_moves : wether global moves should be proposed global_rate : frequency for proposing global moves seed : initialize MC with custom seed Afterwards, you can run the simulation by run! ( mc ) Note that you can just do another run!(mc, sweeps=1000) to continue the simulation. Examples You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model . Exports # MonteCarlo.run! Method . run! ( mc :: MC [; verbose :: Bool = true , sweeps :: Int , thermalization :: Int ]) Runs the given Monte Carlo simulation mc . Progress will be printed to stdout if verbose=true (default). source # MonteCarlo.MC Type . Monte Carlo simulation source # MonteCarlo.MC Method . MC ( m :: M ; kwargs ... ) where M : Model Create a Monte Carlo simulation for model m with keyword parameters kwargs . source # MonteCarlo.MC Method . MC ( m :: M , params :: Dict ) MC ( m :: M , params :: NamedTuple ) Create a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params . source Potential extensions Pull requests are very much welcome! Heat bath (instead of Metropolis) option","title":"MC"},{"location":"flavors/mc/#monte-carlo-mc","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model ). You can initialize a Monte Carlo simulation of a given model simply through mc = MC ( model ) Allowed keywords are: beta : inverse temperature sweeps : number of measurement sweeps thermalization : number of thermalization (warmup) sweeps global_moves : wether global moves should be proposed global_rate : frequency for proposing global moves seed : initialize MC with custom seed Afterwards, you can run the simulation by run! ( mc ) Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","title":"Monte Carlo (MC)"},{"location":"flavors/mc/#examples","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model .","title":"Examples"},{"location":"flavors/mc/#exports","text":"# MonteCarlo.run! Method . run! ( mc :: MC [; verbose :: Bool = true , sweeps :: Int , thermalization :: Int ]) Runs the given Monte Carlo simulation mc . Progress will be printed to stdout if verbose=true (default). source # MonteCarlo.MC Type . Monte Carlo simulation source # MonteCarlo.MC Method . MC ( m :: M ; kwargs ... ) where M : Model Create a Monte Carlo simulation for model m with keyword parameters kwargs . source # MonteCarlo.MC Method . MC ( m :: M , params :: Dict ) MC ( m :: M , params :: NamedTuple ) Create a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params . source","title":"Exports"},{"location":"flavors/mc/#potential-extensions","text":"Pull requests are very much welcome! Heat bath (instead of Metropolis) option","title":"Potential extensions"},{"location":"interfaces/DQMC/","text":"Interface: Determinant Quantum Monte Carlo (DQMC) Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC) . Example models: Attractive Hubbard Model Mandatory fields l::AbstractLattice : any AbstractLattice flv::Int : number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N) , where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions. Index of all methods MonteCarlo.accept_local MonteCarlo.energy_boson MonteCarlo.greenseltype MonteCarlo.hopping_matrix MonteCarlo.interaction_matrix_exp! Mandatory methods Missing docstring. Missing docstring for conftype(::Type{DQMC}, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for rand(::DQMC, ::Model) . Check Documenter's build log for details. # MonteCarlo.hopping_matrix Method . hopping_matrix ( mc :: DQMC , m :: Model ) Calculates the hopping matrix T_{i\\sigma, j\\sigma '} T_{i\\sigma, j\\sigma '} where i, j i, j are site indices and \\sigma , \\sigma ' \\sigma , \\sigma ' are flavor indices (e.g. spin indices). The hopping matrix should also contain potential chemical potential terms on the diagonal. A matrix element is the hopping amplitude for a hopping process: j,\\sigma ' \\rightarrow i,\\sigma j,\\sigma ' \\rightarrow i,\\sigma . Regarding the order of indices, if T[i, \u03c3, j, \u03c3'] is your desired 4D hopping array, then reshape(T, (n_sites * n_flavors, :)) is the hopping matrix. source # MonteCarlo.interaction_matrix_exp! Function . interaction_matrix_exp! ( mc :: DQMC , m :: Model , result :: Matrix , conf , slice :: Int , power :: Float64 = 1. ) - nothing Calculate the interaction matrix exponential expV = exp(- power * delta_tau * V(slice)) and store it in result::Matrix . Potential chemical potential terms should be part of the hopping_matrix and not the interaction. This is a performance critical method and one might consider efficient in-place (in result ) construction. source Missing docstring. Missing docstring for propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64) . Check Documenter's build log for details. # MonteCarlo.accept_local Method . accept_local ( mc :: DQMC , m :: Model , i :: Int , slice :: Int , conf , \u0394 , detratio , \u0394E_boson ) Accept a local move for site i at imaginary time slice slice of current configuration conf . Arguments \u0394 , detratio and \u0394E_boson correspond to output of propose_local for that local move. See also propose_local . source Optional methods # MonteCarlo.greenseltype Method . greenseltype ( :: Type { DQMC }, m :: Model ) Returns the type of the elements of the Green's function matrix. Defaults to ComplexF64 . source # MonteCarlo.energy_boson Method . energy ( mc :: DQMC , m :: Model , conf ) Calculate bosonic part (non-Green's function determinant part) of energy for configuration conf for Model m . source Missing docstring. Missing docstring for prepare_observables(mc::DQMC, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf) . Check Documenter's build log for details. Missing docstring. Missing docstring for finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}) . Check Documenter's build log for details.","title":"DQMC"},{"location":"interfaces/DQMC/#interface-determinant-quantum-monte-carlo-dqmc","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC) . Example models: Attractive Hubbard Model","title":"Interface: Determinant Quantum Monte Carlo (DQMC)"},{"location":"interfaces/DQMC/#mandatory-fields","text":"l::AbstractLattice : any AbstractLattice flv::Int : number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N) , where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","title":"Mandatory fields"},{"location":"interfaces/DQMC/#index-of-all-methods","text":"MonteCarlo.accept_local MonteCarlo.energy_boson MonteCarlo.greenseltype MonteCarlo.hopping_matrix MonteCarlo.interaction_matrix_exp!","title":"Index of all methods"},{"location":"interfaces/DQMC/#mandatory-methods","text":"Missing docstring. Missing docstring for conftype(::Type{DQMC}, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for rand(::DQMC, ::Model) . Check Documenter's build log for details. # MonteCarlo.hopping_matrix Method . hopping_matrix ( mc :: DQMC , m :: Model ) Calculates the hopping matrix T_{i\\sigma, j\\sigma '} T_{i\\sigma, j\\sigma '} where i, j i, j are site indices and \\sigma , \\sigma ' \\sigma , \\sigma ' are flavor indices (e.g. spin indices). The hopping matrix should also contain potential chemical potential terms on the diagonal. A matrix element is the hopping amplitude for a hopping process: j,\\sigma ' \\rightarrow i,\\sigma j,\\sigma ' \\rightarrow i,\\sigma . Regarding the order of indices, if T[i, \u03c3, j, \u03c3'] is your desired 4D hopping array, then reshape(T, (n_sites * n_flavors, :)) is the hopping matrix. source # MonteCarlo.interaction_matrix_exp! Function . interaction_matrix_exp! ( mc :: DQMC , m :: Model , result :: Matrix , conf , slice :: Int , power :: Float64 = 1. ) - nothing Calculate the interaction matrix exponential expV = exp(- power * delta_tau * V(slice)) and store it in result::Matrix . Potential chemical potential terms should be part of the hopping_matrix and not the interaction. This is a performance critical method and one might consider efficient in-place (in result ) construction. source Missing docstring. Missing docstring for propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64) . Check Documenter's build log for details. # MonteCarlo.accept_local Method . accept_local ( mc :: DQMC , m :: Model , i :: Int , slice :: Int , conf , \u0394 , detratio , \u0394E_boson ) Accept a local move for site i at imaginary time slice slice of current configuration conf . Arguments \u0394 , detratio and \u0394E_boson correspond to output of propose_local for that local move. See also propose_local . source","title":"Mandatory methods"},{"location":"interfaces/DQMC/#optional-methods","text":"# MonteCarlo.greenseltype Method . greenseltype ( :: Type { DQMC }, m :: Model ) Returns the type of the elements of the Green's function matrix. Defaults to ComplexF64 . source # MonteCarlo.energy_boson Method . energy ( mc :: DQMC , m :: Model , conf ) Calculate bosonic part (non-Green's function determinant part) of energy for configuration conf for Model m . source Missing docstring. Missing docstring for prepare_observables(mc::DQMC, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf) . Check Documenter's build log for details. Missing docstring. Missing docstring for finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}) . Check Documenter's build log for details.","title":"Optional methods"},{"location":"interfaces/MC/","text":"Interface: Monte Carlo (MC) Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC) . Example models: Ising Model Mandatory fields l::Lattice : any Lattice Index of all methods Mandatory methods Missing docstring. Missing docstring for conftype(::Type{MC}, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for energy(mc::MC, m::Model, conf) . Check Documenter's build log for details. Missing docstring. Missing docstring for rand(::MC, ::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for propose_local(mc::MC, m::Model, i::Int, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64) . Check Documenter's build log for details. Optional methods Missing docstring. Missing docstring for global_move(mc::MC, m::Model, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for prepare_observables(mc::MC, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable}) . Check Documenter's build log for details.","title":"MC"},{"location":"interfaces/MC/#interface-monte-carlo-mc","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC) . Example models: Ising Model","title":"Interface: Monte Carlo (MC)"},{"location":"interfaces/MC/#mandatory-fields","text":"l::Lattice : any Lattice","title":"Mandatory fields"},{"location":"interfaces/MC/#index-of-all-methods","text":"","title":"Index of all methods"},{"location":"interfaces/MC/#mandatory-methods","text":"Missing docstring. Missing docstring for conftype(::Type{MC}, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for energy(mc::MC, m::Model, conf) . Check Documenter's build log for details. Missing docstring. Missing docstring for rand(::MC, ::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for propose_local(mc::MC, m::Model, i::Int, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64) . Check Documenter's build log for details.","title":"Mandatory methods"},{"location":"interfaces/MC/#optional-methods","text":"Missing docstring. Missing docstring for global_move(mc::MC, m::Model, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for prepare_observables(mc::MC, m::Model) . Check Documenter's build log for details. Missing docstring. Missing docstring for measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64) . Check Documenter's build log for details. Missing docstring. Missing docstring for finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable}) . Check Documenter's build log for details.","title":"Optional methods"},{"location":"manual/gettingstarted/","text":"Getting Started Installation MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL: Pkg . clone ( https://github.com/crstnbr/MonteCarloObservable.jl ) Pkg . clone ( https://github.com/crstnbr/MonteCarlo.jl ) To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\") . Warning The package is still in pre-alpha phase and shouldn't yet be used for production runs. Usage This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model: # load packages using MonteCarlo # load your model m = IsingModel ( dims = 2 , L = 8 ); # choose a Monte Carlo flavor and run the simulation mc = MC ( m , beta = 0.35 ); run! ( mc , sweeps = 1000 , thermalization = 1000 , verbose = false ); # analyze results observables ( mc ) # what observables do exist for that simulation? m = mc . obs [ m ] # magnetization mean ( m ) std ( m ) # one-sigma error # create standard plots hist ( m ) plot ( m )","title":"Getting started"},{"location":"manual/gettingstarted/#getting-started","text":"","title":"Getting Started"},{"location":"manual/gettingstarted/#installation","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL: Pkg . clone ( https://github.com/crstnbr/MonteCarloObservable.jl ) Pkg . clone ( https://github.com/crstnbr/MonteCarlo.jl ) To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\") . Warning The package is still in pre-alpha phase and shouldn't yet be used for production runs.","title":"Installation"},{"location":"manual/gettingstarted/#usage","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model: # load packages using MonteCarlo # load your model m = IsingModel ( dims = 2 , L = 8 ); # choose a Monte Carlo flavor and run the simulation mc = MC ( m , beta = 0.35 ); run! ( mc , sweeps = 1000 , thermalization = 1000 , verbose = false ); # analyze results observables ( mc ) # what observables do exist for that simulation? m = mc . obs [ m ] # magnetization mean ( m ) std ( m ) # one-sigma error # create standard plots hist ( m ) plot ( m )","title":"Usage"},{"location":"manual/showcase/","text":"Showcase 2D Ising model Results: Code: using MonteCarlo , Distributions , PyPlot , DataFrames , JLD Tdist = Normal ( MonteCarlo . IsingTc , . 64 ) n_Ts = 2 ^ 8 Ts = sort! ( rand ( Tdist , n_Ts )) Ts = Ts [ Ts . = 1.2 ] Ts = Ts [ Ts . = 3.8 ] therm = 10 ^ 4 sweeps = 10 ^ 3 df = DataFrame ( L = Int [], T = Float64 [], M = Float64 [], \u03c7 = Float64 [], E = Float64 [], C_V = Float64 []) for L in 2 .^ [ 3 , 4 , 5 , 6 ] println ( L = , L ) for ( i , T ) in enumerate ( Ts ) println ( \\t T = , T ) beta = 1 / T model = IsingModel ( dims = 2 , L = L ) mc = MC ( model , beta = beta ) run! ( mc , sweeps = sweeps , thermalization = therm , verbose = false ) push! ( df , [ L , T , mean ( mc . obs [ m ]), mean ( mc . obs [ \u03c7 ]), mean ( mc . obs [ e ]), mean ( mc . obs [ C ])]) end flush ( stdout ) end sort! ( df , [ : L , : T ]) @save ising2d.jld df # plot results together grps = groupby ( df , : L ) fig , ax = subplots ( 2 , 2 , figsize = ( 12 , 8 )) for g in grps L = g [ : L ][ 1 ] ax [ 1 ] . plot ( g [ : T ], g [ : E ], o , markeredgecolor = black , label = L= $L ) ax [ 2 ] . plot ( g [ : T ], g [ : C_V ], o , markeredgecolor = black , label = L= $L ) ax [ 3 ] . plot ( g [ : T ], g [ : M ], o , markeredgecolor = black , label = L= $L ) ax [ 4 ] . plot ( g [ : T ], g [ : \u03c7 ], o , markeredgecolor = black , label = L= $L ) end ax [ 1 ] . legend ( loc = best ) ax [ 1 ] . set_ylabel ( Energy ) ax [ 1 ] . set_xlabel ( Temperature ) ax [ 2 ] . set_ylabel ( Specific heat ) ax [ 2 ] . set_xlabel ( Temperature ) ax [ 2 ] . axvline ( x = MonteCarlo . IsingTc , color = black , linestyle = dashed , label = \\$ T_c \\$ ) ax [ 2 ] . legend ( loc = best ) ax [ 3 ] . set_ylabel ( Magnetization ) ax [ 3 ] . set_xlabel ( Temperature ) x = range ( 1.2 , stop = MonteCarlo . IsingTc , length = 100 ) y = ( 1 .- sinh . ( 2.0 ./ ( x )) .^ ( - 4 )) .^ ( 1 / 8 ) ax [ 3 ] . plot ( x , y , k-- , label = exact ) ax [ 3 ] . plot ( range ( MonteCarlo . IsingTc , stop = 3.8 , length = 100 ), zeros ( 100 ), k-- ) ax [ 3 ] . legend ( loc = best ) ax [ 4 ] . set_ylabel ( Susceptibility \u03c7 ) ax [ 4 ] . set_xlabel ( Temperature ) ax [ 4 ] . axvline ( x = MonteCarlo . IsingTc , color = black , linestyle = dashed , label = \\$ T_c \\$ ) ax [ 4 ] . legend ( loc = best ) tight_layout () savefig ( ising2d.pdf )","title":"Showcase"},{"location":"manual/showcase/#showcase","text":"","title":"Showcase"},{"location":"manual/showcase/#2d-ising-model","text":"Results: Code: using MonteCarlo , Distributions , PyPlot , DataFrames , JLD Tdist = Normal ( MonteCarlo . IsingTc , . 64 ) n_Ts = 2 ^ 8 Ts = sort! ( rand ( Tdist , n_Ts )) Ts = Ts [ Ts . = 1.2 ] Ts = Ts [ Ts . = 3.8 ] therm = 10 ^ 4 sweeps = 10 ^ 3 df = DataFrame ( L = Int [], T = Float64 [], M = Float64 [], \u03c7 = Float64 [], E = Float64 [], C_V = Float64 []) for L in 2 .^ [ 3 , 4 , 5 , 6 ] println ( L = , L ) for ( i , T ) in enumerate ( Ts ) println ( \\t T = , T ) beta = 1 / T model = IsingModel ( dims = 2 , L = L ) mc = MC ( model , beta = beta ) run! ( mc , sweeps = sweeps , thermalization = therm , verbose = false ) push! ( df , [ L , T , mean ( mc . obs [ m ]), mean ( mc . obs [ \u03c7 ]), mean ( mc . obs [ e ]), mean ( mc . obs [ C ])]) end flush ( stdout ) end sort! ( df , [ : L , : T ]) @save ising2d.jld df # plot results together grps = groupby ( df , : L ) fig , ax = subplots ( 2 , 2 , figsize = ( 12 , 8 )) for g in grps L = g [ : L ][ 1 ] ax [ 1 ] . plot ( g [ : T ], g [ : E ], o , markeredgecolor = black , label = L= $L ) ax [ 2 ] . plot ( g [ : T ], g [ : C_V ], o , markeredgecolor = black , label = L= $L ) ax [ 3 ] . plot ( g [ : T ], g [ : M ], o , markeredgecolor = black , label = L= $L ) ax [ 4 ] . plot ( g [ : T ], g [ : \u03c7 ], o , markeredgecolor = black , label = L= $L ) end ax [ 1 ] . legend ( loc = best ) ax [ 1 ] . set_ylabel ( Energy ) ax [ 1 ] . set_xlabel ( Temperature ) ax [ 2 ] . set_ylabel ( Specific heat ) ax [ 2 ] . set_xlabel ( Temperature ) ax [ 2 ] . axvline ( x = MonteCarlo . IsingTc , color = black , linestyle = dashed , label = \\$ T_c \\$ ) ax [ 2 ] . legend ( loc = best ) ax [ 3 ] . set_ylabel ( Magnetization ) ax [ 3 ] . set_xlabel ( Temperature ) x = range ( 1.2 , stop = MonteCarlo . IsingTc , length = 100 ) y = ( 1 .- sinh . ( 2.0 ./ ( x )) .^ ( - 4 )) .^ ( 1 / 8 ) ax [ 3 ] . plot ( x , y , k-- , label = exact ) ax [ 3 ] . plot ( range ( MonteCarlo . IsingTc , stop = 3.8 , length = 100 ), zeros ( 100 ), k-- ) ax [ 3 ] . legend ( loc = best ) ax [ 4 ] . set_ylabel ( Susceptibility \u03c7 ) ax [ 4 ] . set_xlabel ( Temperature ) ax [ 4 ] . axvline ( x = MonteCarlo . IsingTc , color = black , linestyle = dashed , label = \\$ T_c \\$ ) ax [ 4 ] . legend ( loc = best ) tight_layout () savefig ( ising2d.pdf )","title":"2D Ising model"},{"location":"methods/general/","text":"Methods: General Below you find all general exports. Index Base.length MonteCarlo.reset! MonteCarlo.run! Documentation # Base.length Method . length ( l :: AbstractLattice ) Number of lattice sites. source # MonteCarlo.reset! Method . reset! ( mc :: MonteCarloFlavor ) Resets the Monte Carlo simulation mc . Previously set parameters will be retained. source # MonteCarlo.run! Method . run! ( mc ) Run the Monte Carlo Simulation. source","title":"General exports"},{"location":"methods/general/#methods-general","text":"Below you find all general exports.","title":"Methods: General"},{"location":"methods/general/#index","text":"Base.length MonteCarlo.reset! MonteCarlo.run!","title":"Index"},{"location":"methods/general/#documentation","text":"# Base.length Method . length ( l :: AbstractLattice ) Number of lattice sites. source # MonteCarlo.reset! Method . reset! ( mc :: MonteCarloFlavor ) Resets the Monte Carlo simulation mc . Previously set parameters will be retained. source # MonteCarlo.run! Method . run! ( mc ) Run the Monte Carlo Simulation. source","title":"Documentation"},{"location":"models/hubbardattractive/","text":"Attractive Hubbard Model Hamiltonian The Hamiltonian of the attractive (negative U U ) Hubbard model reads \\begin{align} \\mathcal{H} = -t \\sum*{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger*{i\\sigma} c*{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum*j \\left( n*{j\\uparrow} - \\frac{1}{2} \\right) \\left( n*{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum*j n*{j}, \\end{align} \\begin{align} \\mathcal{H} = -t \\sum*{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger*{i\\sigma} c*{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum*j \\left( n*{j\\uparrow} - \\frac{1}{2} \\right) \\left( n*{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum*j n*{j}, \\end{align} where \\sigma \\sigma denotes spin, t t is the hopping amplitude, U U the on-site repulsive interaction strength, \\mu \\mu the chemical potential and \\langle i, j \\rangle \\langle i, j \\rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that \\mu = 0 \\mu = 0 corresponds to half-filling. Constructor You can create an attractive Hubbard model instance as follows, model = HubbardModelAttractive ( dims = 1 , L = 8 ) The following parameters can be set via keyword arguments: dims::Int : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.) L::Int : linear system size t::Float64 = 1.0 : hopping energy U::Float64 = 1.0 : onsite interaction strength, \"Hubbard U U \" mu::Float64 = 0.0 : chemical potential Supported Monte Carlo flavors Determinant Quantum Monte Carlo (DQMC) , see details below DQMC formulation We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel, \\begin{align} e^{|U|\\Delta \\tau \\left( n*{i\\uparrow} - \\frac{1}{2} \\right) \\left(n*{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum*{s=\\pm 1} \\prod*{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align} \\begin{align} e^{|U|\\Delta \\tau \\left( n*{i\\uparrow} - \\frac{1}{2} \\right) \\left(n*{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum*{s=\\pm 1} \\prod*{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align} The interaction matrix of the model then reads \\begin{align} V*{ij}(l) = \\delta*{ij} V*i(l), \\\\ V*i(l) = - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align} \\begin{align} V*{ij}(l) &= \\delta*{ij} V*i(l), \\\\ V*i(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align} For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\ -\\mu & \\text{if i == j,} \\\\ 0 & \\text{otherwise.} \\end{cases} \\end{align} As neither T T nor V V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor ( flv=1 ) and benefit from operating with smaller matrices. Potential extensions Pull requests are very much welcome! Arbitrary lattices (so far only cubic lattices supported)","title":"Attractive Hubbard Model"},{"location":"models/hubbardattractive/#attractive-hubbard-model","text":"","title":"Attractive Hubbard Model"},{"location":"models/hubbardattractive/#hamiltonian","text":"The Hamiltonian of the attractive (negative U U ) Hubbard model reads \\begin{align} \\mathcal{H} = -t \\sum*{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger*{i\\sigma} c*{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum*j \\left( n*{j\\uparrow} - \\frac{1}{2} \\right) \\left( n*{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum*j n*{j}, \\end{align} \\begin{align} \\mathcal{H} = -t \\sum*{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger*{i\\sigma} c*{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum*j \\left( n*{j\\uparrow} - \\frac{1}{2} \\right) \\left( n*{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum*j n*{j}, \\end{align} where \\sigma \\sigma denotes spin, t t is the hopping amplitude, U U the on-site repulsive interaction strength, \\mu \\mu the chemical potential and \\langle i, j \\rangle \\langle i, j \\rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that \\mu = 0 \\mu = 0 corresponds to half-filling.","title":"Hamiltonian"},{"location":"models/hubbardattractive/#constructor","text":"You can create an attractive Hubbard model instance as follows, model = HubbardModelAttractive ( dims = 1 , L = 8 ) The following parameters can be set via keyword arguments: dims::Int : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.) L::Int : linear system size t::Float64 = 1.0 : hopping energy U::Float64 = 1.0 : onsite interaction strength, \"Hubbard U U \" mu::Float64 = 0.0 : chemical potential","title":"Constructor"},{"location":"models/hubbardattractive/#supported-monte-carlo-flavors","text":"Determinant Quantum Monte Carlo (DQMC) , see details below","title":"Supported Monte Carlo flavors"},{"location":"models/hubbardattractive/#dqmc-formulation","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel, \\begin{align} e^{|U|\\Delta \\tau \\left( n*{i\\uparrow} - \\frac{1}{2} \\right) \\left(n*{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum*{s=\\pm 1} \\prod*{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align} \\begin{align} e^{|U|\\Delta \\tau \\left( n*{i\\uparrow} - \\frac{1}{2} \\right) \\left(n*{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum*{s=\\pm 1} \\prod*{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align} The interaction matrix of the model then reads \\begin{align} V*{ij}(l) = \\delta*{ij} V*i(l), \\\\ V*i(l) = - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align} \\begin{align} V*{ij}(l) &= \\delta*{ij} V*i(l), \\\\ V*i(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align} For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\ -\\mu & \\text{if i == j,} \\\\ 0 & \\text{otherwise.} \\end{cases} \\end{align} As neither T T nor V V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor ( flv=1 ) and benefit from operating with smaller matrices.","title":"DQMC formulation"},{"location":"models/hubbardattractive/#potential-extensions","text":"Pull requests are very much welcome! Arbitrary lattices (so far only cubic lattices supported)","title":"Potential extensions"},{"location":"models/ising/","text":"Ising Model Hamiltonian The famous Hamiltonian of the Ising model is given by \\begin{align} \\mathcal{H} = -\\sum*{\\langle i,j \\rangle} \\sigma*i \\sigma_j , \\end{align} \\begin{align} \\mathcal{H} = -\\sum*{\\langle i,j \\rangle} \\sigma*i \\sigma_j , \\end{align} where \\langle i, j \\rangle \\langle i, j \\rangle indicates that the sum has to be taken over nearest neighbors. Creating an Ising model You can create an Ising model as follows, model = IsingModel (; dims :: Int = 2 , L :: Int = 8 ) The following parameters can be set via keyword arguments: dims : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.) L : linear system size Supported Monte Carlo flavors Monte Carlo (MC) (Have a look at the examples section below) Examples You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model . Exports # MonteCarlo.IsingModel Method . IsingModel ( params :: Dict ) IsingModel ( params :: NamedTuple ) Create an Ising model with (keyword) parameters as specified in the dictionary/named tuple params . source Analytic results Square lattice (2D) The model can be solved exactly by transfer matrix method ( Onsager solution ). This gives the following results. Critical temperature: T_c = \\frac{2}{\\ln{1+\\sqrt{2}}} T_c = \\frac{2}{\\ln{1+\\sqrt{2}}} Magnetization (per site): m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}} m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}} Potential extensions Pull requests are very much welcome! Arbitrary dimensions Magnetic field Maybe explicit J J instead of implicit J=1 J=1 Non-cubic lattices (just add lattice::AbstractLattice keyword)","title":"Ising Model"},{"location":"models/ising/#ising-model","text":"","title":"Ising Model"},{"location":"models/ising/#hamiltonian","text":"The famous Hamiltonian of the Ising model is given by \\begin{align} \\mathcal{H} = -\\sum*{\\langle i,j \\rangle} \\sigma*i \\sigma_j , \\end{align} \\begin{align} \\mathcal{H} = -\\sum*{\\langle i,j \\rangle} \\sigma*i \\sigma_j , \\end{align} where \\langle i, j \\rangle \\langle i, j \\rangle indicates that the sum has to be taken over nearest neighbors.","title":"Hamiltonian"},{"location":"models/ising/#creating-an-ising-model","text":"You can create an Ising model as follows, model = IsingModel (; dims :: Int = 2 , L :: Int = 8 ) The following parameters can be set via keyword arguments: dims : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.) L : linear system size","title":"Creating an Ising model"},{"location":"models/ising/#supported-monte-carlo-flavors","text":"Monte Carlo (MC) (Have a look at the examples section below)","title":"Supported Monte Carlo flavors"},{"location":"models/ising/#examples","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model .","title":"Examples"},{"location":"models/ising/#exports","text":"# MonteCarlo.IsingModel Method . IsingModel ( params :: Dict ) IsingModel ( params :: NamedTuple ) Create an Ising model with (keyword) parameters as specified in the dictionary/named tuple params . source","title":"Exports"},{"location":"models/ising/#analytic-results","text":"","title":"Analytic results"},{"location":"models/ising/#square-lattice-2d","text":"The model can be solved exactly by transfer matrix method ( Onsager solution ). This gives the following results. Critical temperature: T_c = \\frac{2}{\\ln{1+\\sqrt{2}}} T_c = \\frac{2}{\\ln{1+\\sqrt{2}}} Magnetization (per site): m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}} m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}}","title":"Square lattice (2D)"},{"location":"models/ising/#potential-extensions","text":"Pull requests are very much welcome! Arbitrary dimensions Magnetic field Maybe explicit J J instead of implicit J=1 J=1 Non-cubic lattices (just add lattice::AbstractLattice keyword)","title":"Potential extensions"}]}